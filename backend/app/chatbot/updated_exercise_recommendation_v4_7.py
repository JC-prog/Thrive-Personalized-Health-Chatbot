# -*- coding: utf-8 -*-
"""[Updated] Exercise recommendation v4.7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gYb2TdKEVPJ6jDz4IiYk98xDFqfolbaJ

# 1. Initial Setup
"""

# !pip install pykeen
# !pip install NetworkX

# Core imports
import pandas as pd
import numpy as np
import re
import json
import time
import random
from typing import List, Dict, Tuple, Optional, Any, Union
import os

# For clinical knowledge graph
import enum
from enum import Enum
import networkx as nx

# For exercise mbeddings and similarity
import torch
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
# from pykeen.triples import TriplesFactory

print("All imports successful!")

"""# 2. Data Processing and Exploration"""

import pandas as pd
current_dir = os.path.dirname(os.path.abspath(__file__)) 
csv_path = os.path.join(current_dir, 'data', 'combined_exercise_dataset.csv')

combined_exercises_df = pd.read_csv(csv_path)  # update path if needed
print(combined_exercises_df.columns.tolist())

"""# 3. User Profile"""

# User Profile Module
# Handles initialization and validation of user profiles

def initialize_user_profile(age=None, gender=None, height=None, weight=None,
                         bp_systolic=None, bp_diastolic=None, glucose=None,
                         cholesterol=None, fitness_level=None, fitness_goal=None,
                         sessions_per_week=None, equipment=None):
    """Initialize or collect user profile with defaults

    Args:
        age: User's age (default: 40)
        gender: User's gender (default: "not specified")
        height: User's height in cm (default: 170.0)
        weight: User's weight in kg (default: 70.0)
        bp_systolic: Systolic blood pressure (default: 120)
        bp_diastolic: Diastolic blood pressure (default: 80)
        glucose: Blood glucose level (default: 100)
        cholesterol: Blood cholesterol level (default: 180)
        fitness_level: User's fitness level (default: "beginner")
        fitness_goal: User's fitness goal (default: "general")
        sessions_per_week: Number of weekly workout sessions (default: 3)
        equipment: Available equipment (default: ["Bodyweight"])

    Returns:
        Dict: Complete user profile with derived metrics
    """
    # Initialize with provided values or defaults
    profile = {
        "demographics": {
            "age": age if age is not None else 40,
            "gender": gender.lower() if gender is not None else "not specified"
        },
        "body_metrics": {
            "height": height if height is not None else 170.0,  # cm
            "weight": weight if weight is not None else 70.0    # kg
        },
        "health_metrics": {
            "bp_systolic": bp_systolic if bp_systolic is not None else 120,
            "bp_diastolic": bp_diastolic if bp_diastolic is not None else 80,
            "glucose": glucose if glucose is not None else 100,
            "cholesterol": cholesterol if cholesterol is not None else 180
        },
        "fitness_info": {
            "fitness_level": fitness_level.lower() if fitness_level is not None else "beginner",
            "fitness_goal": fitness_goal.lower() if fitness_goal is not None else "general",
        },
        "preferences": {
            "sessions_per_week": sessions_per_week if sessions_per_week is not None else 3,
            "equipment": equipment if equipment is not None else ["Bodyweight"]
        }
    }

    # Calculate BMI
    height_m = profile["body_metrics"]["height"] / 100  # convert cm to m
    profile["body_metrics"]["bmi"] = round(profile["body_metrics"]["weight"] / (height_m * height_m), 1)

    # Determine health condition flags
    profile["health_conditions"] = {
        "has_hypertension": (profile["health_metrics"]["bp_systolic"] >= 130 or
                           profile["health_metrics"]["bp_diastolic"] >= 85),
        "has_diabetes": profile["health_metrics"]["glucose"] >= 126,  # Fasting glucose ≥126 mg/dL
        "has_high_cholesterol": profile["health_metrics"]["cholesterol"] >= 200,
        "has_obesity": profile["body_metrics"]["bmi"] >= 30 if profile["body_metrics"]["bmi"] else False
    }

    # Calculate age-related max heart rate
    profile["exercise_parameters"] = {
        "max_heart_rate": 220 - profile["demographics"]["age"] if profile["demographics"]["age"] else 180,
        "target_heart_rate_zone": {}
    }

    # Calculate target heart rate zones
    max_hr = profile["exercise_parameters"]["max_heart_rate"]
    profile["exercise_parameters"]["target_heart_rate_zone"] = {
        "low_intensity": [int(max_hr * 0.5), int(max_hr * 0.6)],
        "moderate_intensity": [int(max_hr * 0.6), int(max_hr * 0.7)],
        "high_intensity": [int(max_hr * 0.7), int(max_hr * 0.85)]
    }

    return profile

def validate_health_profile(user_profile):
    """Validate the health profile and return a simplified version

    Args:
        user_profile: The complete user profile

    Returns:
        Dict: Simplified health profile with condition flags
    """
    # Extract health metrics to create a simplified health profile
    health_profile = {
        "bp_systolic": user_profile['health_metrics']['bp_systolic'],
        "bp_diastolic": user_profile['health_metrics']['bp_diastolic'],
        "glucose": user_profile['health_metrics']['glucose'],
        "cholesterol": user_profile['health_metrics']['cholesterol'],
        "bmi": user_profile['body_metrics']['bmi']
    }

    # Add derived fields based on standard medical criteria
    health_profile['diabetes_status'] = 1 if user_profile['health_conditions']['has_diabetes'] else 0
    health_profile['has_diabetes'] = user_profile['health_conditions']['has_diabetes']
    health_profile['has_hypertension'] = user_profile['health_conditions']['has_hypertension']
    health_profile['has_high_cholesterol'] = user_profile['health_conditions']['has_high_cholesterol']
    health_profile['has_obesity'] = user_profile['health_conditions']['has_obesity']

    # Log the validation results
    health_conditions = []
    if health_profile['has_diabetes']:
        health_conditions.append("diabetes")
    if health_profile['has_hypertension']:
        health_conditions.append("hypertension")
    if health_profile['has_high_cholesterol']:
        health_conditions.append("high cholesterol")
    if health_profile['has_obesity']:
        health_conditions.append("obesity")

    if health_conditions:
        print(f"Health profile validated: {', '.join(health_conditions)} detected")
    else:
        print("Health profile validated: no health conditions detected")

    return health_profile

# Create a sample user profile for testing
SAMPLE_USER_PROFILE = initialize_user_profile(
    age=28,
    gender="female",
    height=165,
    weight=75,
    bp_systolic=135,
    bp_diastolic=88,
    glucose=130,
    cholesterol=210,
    fitness_level="intermediate",
    sessions_per_week=4
)

"""# [Updated] Clinical Guidelines Knowledge Graph"""

#Latest
"""
Guidelines Knowledge Graph Data (Updated)
-------------------------------
This module defines the nodes and edges for a clinical exercise guidelines knowledge graph.
All clinical knowledge is stored here, eliminating hardcoded values from the application logic.
"""
# Define enums for consistent typing and reference
class NodeType(Enum):
    GUIDELINE = "Guideline"
    HEALTH_CONDITION = "HealthCondition"
    EXERCISE_TYPE = "ExerciseType"
    EXERCISE_MODALITY = "ExerciseModality"
    EXERCISE = "Exercise"
    MUSCLE_GROUP = "MuscleGroup"
    MONITORING_GUIDANCE = "MonitoringGuidance"
    EFFECTIVENESS_RATING = "EffectivenessRating"
    HEALTH_PARAMETER = "HealthParameter"
    HEALTH_NOTE = "HealthNote"
    PATIENT_GROUP = "PatientGroup"
    TREATMENT_PATHWAY = "TreatmentPathway"
    RECOMMENDATION = "Recommendation"
    BENEFIT = "Benefit"
    EXERCISE_PARAMETERS = "ExerciseParameters"
    WORKOUT_SPLIT = "WorkoutSplit"
    RATIONALE = "Rationale"
    TIME_ESTIMATION = "TimeEstimation"

class RelationType(Enum):
    HAS_GUIDELINE = "HAS_GUIDELINE"
    RECOMMENDS = "RECOMMENDS"
    TARGETS = "TARGETS"
    REQUIRES_MONITORING = "REQUIRES_MONITORING"
    HAS_EFFECTIVENESS = "HAS_EFFECTIVENESS"
    AFFECTS = "AFFECTS"
    INCLUDES = "INCLUDES"
    APPLIES_TO = "APPLIES_TO"
    HAS_TREATMENT_PATHWAY = "HAS_TREATMENT_PATHWAY"
    HAS_PATHWAY_CRITERIA = "HAS_PATHWAY_CRITERIA"
    BENEFICIAL_FOR = "BENEFICIAL_FOR"
    CONTRA_INDICATED_FOR = "CONTRA_INDICATED_FOR"
    HAS_INTENSITY = "HAS_INTENSITY"
    HAS_FREQUENCY = "HAS_FREQUENCY"
    HAS_DURATION = "HAS_DURATION"
    HAS_NOTE = "HAS_NOTE"
    HAS_BENEFIT = "HAS_BENEFIT"
    SOURCE_OF = "SOURCE_OF"
    PRIORITIZES_MUSCLE = "PRIORITIZES_MUSCLE"
    HAS_PARAMETERS = "HAS_PARAMETERS"
    HAS_WORKOUT_SPLIT = "HAS_WORKOUT_SPLIT"
    HAS_RATIONALE = "HAS_RATIONALE"
    USES_TIME_ESTIMATION = "USES_TIME_ESTIMATION"

def create_guidelines_graph():
    """Create and return a NetworkX graph with all guidelines knowledge"""
    G = nx.DiGraph()

    # Add guideline sources as nodes
    guidelines = [
        {"id": "singapore_pa", "name": "Singapore Physical Activity Guidelines",
         "description": "Exercise baseline for everybody",
         "source": "Singapore physical activity guidelines for 18-64 years old"},
        {"id": "aha", "name": "American Heart Association Guidelines",
         "description": "Guidelines for using physical activity to treat elevated blood pressure and cholesterol",
         "source": "Physical Activity as a Critical Component of First-Line Treatment for Elevated Blood Pressure or Cholesterol [American Heart Association]"},
        {"id": "modality_effectiveness", "name": "Exercise Modality Effectiveness Guidelines",
         "description": "Effectiveness ratings for different exercise modalities across health parameters",
         "source": "Differential Effects of Aerobic Exercise, Resistance Training and Combined Exercise Modalities"},
        {"id": "diabetes_guidelines", "name": "Diabetes Exercise Guidelines",
         "description": "Exercise recommendations for diabetes management",
         "source": "American Diabetes Association"},
        {"id": "hypertension_guidelines", "name": "Hypertension Exercise Guidelines",
         "description": "Exercise recommendations for hypertension management",
         "source": "American College of Cardiology/American Heart Association"},
        {"id": "cholesterol_guidelines", "name": "Cholesterol Exercise Guidelines",
         "description": "Exercise recommendations for cholesterol management",
         "source": "Differential Effects of Aerobic Exercise, Resistance Training and Combined Exercise Modalities"}
    ]

    for guideline in guidelines:
        G.add_node(
            guideline["id"],
            type=NodeType.GUIDELINE.value,
            name=guideline["name"],
            description=guideline["description"],
            source=guideline["source"]
        )

    # Add health conditions as nodes
    conditions = [
        {"id": "diabetes", "name": "Diabetes", "description": "Type 2 Diabetes"},
        {"id": "hypertension", "name": "Hypertension", "description": "High Blood Pressure"},
        {"id": "high_cholesterol", "name": "High Cholesterol", "description": "Elevated Cholesterol Levels"},
        {"id": "obesity", "name": "Obesity", "description": "Excess Body Fat"}
    ]

    for condition in conditions:
        G.add_node(
            condition["id"],
            type=NodeType.HEALTH_CONDITION.value,
            name=condition["name"],
            description=condition["description"]
        )

    # Add exercise types as nodes
    exercise_types = [
        {"id": "aerobic", "name": "Aerobic", "description": "Cardiovascular exercise that increases heart rate"},
        {"id": "resistance", "name": "Resistance", "description": "Strength training using weights or resistance"},
        {"id": "flexibility", "name": "Flexibility", "description": "Stretching exercises to improve range of motion"},
        {"id": "combined", "name": "Combined", "description": "Workout combining multiple types of exercise"}
    ]

    for ex_type in exercise_types:
        G.add_node(
            ex_type["id"],
            type=NodeType.EXERCISE_TYPE.value,
            name=ex_type["name"],
            description=ex_type["description"]
        )

    # Add muscle groups as nodes
    muscle_groups = [
        {"id": "chest", "name": "Chest", "description": "Pectoral muscles"},
        {"id": "back", "name": "Back", "description": "Back muscles including lats and rhomboids"},
        {"id": "legs", "name": "Legs", "description": "Leg muscles including quadriceps, hamstrings, and calves"},
        {"id": "shoulders", "name": "Shoulders", "description": "Deltoid muscles"},
        {"id": "arms", "name": "Arms", "description": "Arm muscles including biceps and triceps"},
        {"id": "core", "name": "Core", "description": "Abdominal and lower back muscles"},
        {"id": "triceps", "name": "Triceps", "description": "Back of the arm muscles"},
        {"id": "biceps", "name": "Biceps", "description": "Front of the arm muscles"}
    ]

    for muscle in muscle_groups:
        G.add_node(
            muscle["id"],
            type=NodeType.MUSCLE_GROUP.value,
            name=muscle["name"],
            description=muscle["description"]
        )

    # Add exercise parameters for different exercise types
    exercise_parameters = [
        {"id": "resistance_params", "name": "Resistance Exercise Parameters",
         "rest_period": {"min": 60, "max": 90, "unit": "seconds"},
         "time_per_set": 1.5,  # minutes per set including rest
         "default_sets": {"min": 2, "max": 3},
         "default_reps": {"min": 8, "max": 12}},

        {"id": "flexibility_params", "name": "Flexibility Exercise Parameters",
         "duration": {"min": 30, "max": 45, "unit": "seconds"},
         "repetitions": 2,
         "time_per_stretch": 1.5,  # minutes per stretch including transition
         "notes": "Perform each stretch twice, holding for 30-45 seconds"},

        {"id": "aerobic_params", "name": "Aerobic Exercise Parameters",
         "default_duration": {"min": 20, "max": 30, "unit": "minutes"},
         "warmup_duration": 5,
         "cooldown_duration": 5}
    ]

    for param in exercise_parameters:
        G.add_node(
            param["id"],
            type=NodeType.EXERCISE_PARAMETERS.value,
            name=param["name"],
            **{k: v for k, v in param.items() if k not in ["id", "name"]}
        )

    # Connect exercise types to their parameters
    G.add_edge("resistance", "resistance_params", type=RelationType.HAS_PARAMETERS.value)
    G.add_edge("flexibility", "flexibility_params", type=RelationType.HAS_PARAMETERS.value)
    G.add_edge("aerobic", "aerobic_params", type=RelationType.HAS_PARAMETERS.value)

    # Add workout splits for resistance training
    workout_splits = [
        {"id": "push_muscles", "name": "Push Day Muscles",
         "muscle_groups": ["chest", "shoulders", "triceps"],
         "applies_to_days": ["Monday", "Thursday"]},

        {"id": "pull_muscles", "name": "Pull Day Muscles",
         "muscle_groups": ["back", "biceps"],
         "applies_to_days": ["Tuesday", "Friday"]},

        {"id": "leg_core_muscles", "name": "Leg and Core Day Muscles",
         "muscle_groups": ["legs", "core"],
         "applies_to_days": ["Wednesday", "Saturday", "Sunday"]}
    ]

    for split in workout_splits:
        G.add_node(
            split["id"],
            type=NodeType.WORKOUT_SPLIT.value,
            name=split["name"],
            muscle_groups=split["muscle_groups"],
            applies_to_days=split["applies_to_days"]
        )

        # Connect to resistance exercise type
        G.add_edge("resistance", split["id"], type=RelationType.HAS_WORKOUT_SPLIT.value)

    # Add muscle prioritization for conditions
    muscle_prioritizations = [
        {"condition": "diabetes", "exercise_type": "resistance",
         "priority_muscles": ["legs", "back", "chest"],
         "reason": "Large muscle groups for maximum metabolic impact"},

        {"condition": "hypertension", "exercise_type": "aerobic",
         "priority_muscles": ["legs", "core"],
         "reason": "Main muscles for cardiovascular exercise"}
    ]

    for priority in muscle_prioritizations:
        # Create an ID for this prioritization relationship
        priority_id = f"{priority['condition']}_{priority['exercise_type']}_priority"

        # Add the prioritization as a node
        G.add_node(
            priority_id,
            type="MusclePrioritization",
            priority_muscles=priority["priority_muscles"],
            reason=priority["reason"]
        )

        # Connect it to the condition and exercise type
        G.add_edge(priority["condition"], priority_id, type=RelationType.PRIORITIZES_MUSCLE.value)
        G.add_edge(priority["exercise_type"], priority_id, type=RelationType.APPLIES_TO.value)

    # Add rationale text for different session types and conditions
    rationales = [
        {"id": "resistance_diabetes_rationale", "condition": "diabetes", "session_type": "resistance",
         "text": "Resistance training is crucial for managing diabetes by improving insulin sensitivity and glycemic control. Focus on large muscle groups for maximum metabolic impact."},

        {"id": "resistance_hypertension_rationale", "condition": "hypertension", "session_type": "resistance",
         "text": "Resistance training supports overall cardiovascular health when performed with proper breathing techniques. Avoid holding breath during exertion (Valsalva maneuver)."},

        {"id": "resistance_general_rationale", "condition": None, "session_type": "resistance",
         "text": "Resistance training builds muscle strength and improves metabolic health."},

        {"id": "aerobic_cholesterol_rationale", "condition": "high_cholesterol", "session_type": "aerobic",
         "text": "Consistent aerobic exercise is essential for improving cholesterol levels. Aim for moderate-to-high intensity to maximize lipid profile benefits."},

        {"id": "aerobic_hypertension_rationale", "condition": "hypertension", "session_type": "aerobic",
         "text": "Regular aerobic exercise helps reduce blood pressure by improving cardiovascular function. Morning exercise may help control blood pressure throughout the day."},

        {"id": "aerobic_general_rationale", "condition": None, "session_type": "aerobic",
         "text": "Aerobic exercise improves cardiovascular health and endurance."},

        {"id": "combined_general_rationale", "condition": None, "session_type": "combined",
         "text": "Combined training provides comprehensive health benefits by integrating both cardiovascular and resistance exercises, making it efficient for multiple health conditions."}
    ]

    for rationale in rationales:
        G.add_node(
            rationale["id"],
            type=NodeType.RATIONALE.value,
            condition=rationale["condition"],
            session_type=rationale["session_type"],
            text=rationale["text"]
        )

        # Connect to condition if specified
        if rationale["condition"]:
            G.add_edge(rationale["condition"], rationale["id"], type=RelationType.HAS_RATIONALE.value)

    # Add health benefit text for exercises based on conditions
    health_benefits = [
        {"id": "diabetes_resistance_benefit", "condition": "diabetes", "exercise_type": "resistance",
         "text": "Helps improve insulin sensitivity"},

        {"id": "hypertension_aerobic_benefit", "condition": "hypertension", "exercise_type": "aerobic",
         "text": "Helps reduce blood pressure"},

        {"id": "cholesterol_aerobic_benefit", "condition": "high_cholesterol", "exercise_type": "aerobic",
         "text": "Helps improve cholesterol levels"}
    ]

    for benefit in health_benefits:
        G.add_node(
            benefit["id"],
            type=NodeType.BENEFIT.value,
            condition=benefit["condition"],
            exercise_type=benefit["exercise_type"],
            text=benefit["text"]
        )

        # Connect to condition and exercise type
        G.add_edge(benefit["condition"], benefit["id"], type=RelationType.HAS_BENEFIT.value)
        G.add_edge(benefit["exercise_type"], benefit["id"], type=RelationType.BENEFICIAL_FOR.value)

    # Add intensity preferences for conditions
    intensity_preferences = [
        {"id": "hypertension_cardio_intensity", "condition": "hypertension", "exercise_type": "aerobic",
         "preferred_intensity": "moderate", "reason": "Moderate intensity preferred for hypertension"},

        {"id": "hypertension_resistance_intensity", "condition": "hypertension", "exercise_type": "resistance",
         "preferred_intensity": "low", "reason": "Low intensity preferred to avoid BP spikes"},

        {"id": "cholesterol_cardio_intensity", "condition": "high_cholesterol", "exercise_type": "aerobic",
         "preferred_intensity": "moderate_to_vigorous", "reason": "Higher intensity for better lipid profile improvement"}
    ]

    for pref in intensity_preferences:
        G.add_node(
            pref["id"],
            type="IntensityPreference",
            preferred_intensity=pref["preferred_intensity"],
            reason=pref["reason"]
        )

        # Connect to condition and exercise type
        G.add_edge(pref["condition"], pref["id"], type=RelationType.HAS_INTENSITY.value)
        G.add_edge(pref["exercise_type"], pref["id"], type=RelationType.APPLIES_TO.value)

    # Continue with all the other existing nodes and edges from the original...
    # (health parameters, monitoring guidance, health notes, recommendations, etc.)

    # Add health parameters as nodes
    health_parameters = [
        {"id": "blood_pressure", "name": "Blood Pressure", "description": "Systolic and diastolic blood pressure"},
        {"id": "lipid_profile", "name": "Lipid Profile", "description": "Cholesterol levels including LDL, HDL, and triglycerides"},
        {"id": "glycemic_control", "name": "Glycemic Control", "description": "Blood glucose management"},
        {"id": "bodyweight_loss", "name": "Bodyweight Loss", "description": "Reduction in overall bodyweight"},
        {"id": "bodyweight_maintenance", "name": "Bodyweight Maintenance", "description": "Maintaining current bodyweight"},
        {"id": "body_composition_lean_mass", "name": "Lean Mass", "description": "Muscle and other non-fat tissue"},
        {"id": "fat_mass", "name": "Fat Mass", "description": "Body fat percentage and distribution"}
    ]

    for param in health_parameters:
        G.add_node(
            param["id"],
            type=NodeType.HEALTH_PARAMETER.value,
            name=param["name"],
            description=param["description"]
        )

    # Add effectiveness ratings
    ratings = [
        {"id": "minimal", "name": "Minimal Effect", "symbol": "0", "description": "Exercise has minimal effect on this parameter"},
        {"id": "small", "name": "Small to Moderate Benefit", "symbol": "+", "description": "Exercise has a small to moderate benefit on this parameter"},
        {"id": "moderate", "name": "Moderate Benefit", "symbol": "++", "description": "Exercise has a moderate benefit on this parameter"},
        {"id": "large", "name": "Moderate to Large Benefit", "symbol": "+++", "description": "Exercise has a moderate to large benefit on this parameter"}
    ]

    for rating in ratings:
        G.add_node(
            rating["id"],
            type=NodeType.EFFECTIVENESS_RATING.value,
            name=rating["name"],
            symbol=rating["symbol"],
            description=rating["description"]
        )

    # Add patient groups for cholesterol
    patient_groups = [
        {"id": "cholesterol_healthy", "name": "Healthy Cholesterol Levels",
         "description": "LDL < 100, HDL > 40, Total < 200, Triglycerides < 150"},
        {"id": "elevated_cholesterol", "name": "Elevated Cholesterol",
         "description": "LDL > 100, or HDL < 40, or Total > 200, or Triglycerides > 150"},
        {"id": "elevated_cholesterol_limited_mobility", "name": "Elevated Cholesterol with Limited Mobility",
         "description": "Elevated cholesterol with mobility limitations"}
    ]

    for group in patient_groups:
        G.add_node(
            group["id"],
            type=NodeType.PATIENT_GROUP.value,
            name=group["name"],
            description=group["description"]
        )

    # Add monitoring guidance
    monitoring_items = [
        {"id": "diabetes_glucose_monitoring", "name": "Diabetes Glucose Monitoring",
         "description": "Monitor blood glucose before, during (for longer sessions), and after exercise"},
        {"id": "diabetes_carb_preparation", "name": "Diabetes Carbohydrate Preparation",
         "description": "Be prepared with fast-acting carbohydrates in case of hypoglycemia"},
        {"id": "hypertension_bp_monitoring", "name": "Hypertension BP Monitoring",
         "description": "Monitor blood pressure response to exercise if possible"},
        {"id": "cholesterol_consistency", "name": "Cholesterol Exercise Consistency",
         "description": "Focus on consistency of exercise for cholesterol improvement"}
    ]

    for item in monitoring_items:
        G.add_node(
            item["id"],
            type=NodeType.MONITORING_GUIDANCE.value,
            name=item["name"],
            description=item["description"]
        )

    # Add health notes
    health_notes = [
        {"id": "diabetes_timing", "name": "Diabetes Exercise Timing",
         "description": "Exercise 1-3 hours after eating may minimize risk of hypoglycemia"},
        {"id": "hypertension_morning", "name": "Hypertension Morning Exercise",
         "description": "Morning exercise may help control blood pressure throughout the day"},
        {"id": "hypertension_breathing", "name": "Hypertension Breathing",
         "description": "Focus on controlled breathing during exercise"},
        {"id": "hypertension_valsalva", "name": "Hypertension Valsalva Avoidance",
         "description": "Avoid holding breath during resistance exercises (no Valsalva maneuver)"},
        {"id": "cholesterol_aerobic", "name": "Cholesterol Aerobic Exercise",
         "description": "Consistent aerobic exercise is key for cholesterol management"}
    ]

    for note in health_notes:
        G.add_node(
            note["id"],
            type=NodeType.HEALTH_NOTE.value,
            name=note["name"],
            description=note["description"]
        )

    # Add treatment pathways
    pathways = [
        {"id": "bp_normal", "name": "Normal Blood Pressure",
         "criteria": {"sbp": {"max": 119}, "dbp": {"max": 79}},
         "recommendation": "Maintain healthy lifestyle",
         "message": "Your blood pressure is normal. The guidelines recommend maintaining a healthy lifestyle."},
        {"id": "bp_elevated", "name": "Elevated Blood Pressure",
         "criteria": {"sbp": {"min": 120, "max": 129}, "dbp": {"max": 79}},
         "recommendation": "Lifestyle only treatment",
         "message": "Based on your blood pressure levels, lifestyle modifications are recommended as the primary treatment approach."},
        {"id": "cholesterol_low_risk", "name": "Low Risk Cholesterol",
         "criteria": {"ldl_c": {"max": 70}},
         "recommendation": "Maintain healthy lifestyle",
         "message": "Your cholesterol levels are in the low-risk range. The guidelines recommend maintaining a healthy lifestyle."}
    ]

    for pathway in pathways:
        G.add_node(
            pathway["id"],
            type=NodeType.TREATMENT_PATHWAY.value,
            name=pathway["name"],
            criteria=pathway["criteria"],
            recommendation=pathway["recommendation"],
            message=pathway["message"]
        )

    # Add recommendations for exercise types by condition
    recommendations = [
        # Diabetes recommendations
        {"id": "diabetes_aerobic_rec", "name": "Diabetes Aerobic Recommendation",
         "condition": "diabetes", "exercise_type": "aerobic",
         "frequency": {"days_per_week": 3, "max_consecutive_days_rest": 2},
         "intensity": {"moderate": {"duration": 150, "frequency": "weekly"}},
         "description": "At least 3 days/week with no more than 2 consecutive days without activity"},

        {"id": "diabetes_resistance_rec", "name": "Diabetes Resistance Recommendation",
         "condition": "diabetes", "exercise_type": "resistance",
         "frequency": {"days_per_week": 2},
         "sets": {"range": {"min": 1, "max": 3}},
         "repetitions": {"range": {"min": 8, "max": 15}},
         "description": "At least 2 days/week on non-consecutive days"},

        # Hypertension recommendations
        {"id": "hypertension_aerobic_rec", "name": "Hypertension Aerobic Recommendation",
         "condition": "hypertension", "exercise_type": "aerobic",
         "frequency": {"days_per_week": 5},
         "intensity": {"range": {"min": 40, "max": 70}, "unit": "VO2 reserve"},
         "duration": {"range": {"min": 30, "max": 60}, "unit": "minutes per day"},
         "description": "Most days of the week, preferably daily"},

        {"id": "hypertension_resistance_rec", "name": "Hypertension Resistance Recommendation",
         "condition": "hypertension", "exercise_type": "resistance",
         "frequency": {"days_per_week": 2},
         "intensity": {"range": {"min": 60, "max": 80}, "unit": "1RM"},
         "sets": {"count": 1},
         "repetitions": {"range": {"min": 10, "max": 15}},
         "description": "2-3 days per week"},

        # Cholesterol recommendations
        {"id": "cholesterol_healthy_aerobic_rec", "name": "Healthy Cholesterol Aerobic Recommendation",
         "condition": "high_cholesterol", "patient_group": "cholesterol_healthy", "exercise_type": "aerobic",
         "intensity": {"type": "moderate", "range": {"min": 70, "max": 80}, "unit": "HRreserve"},
         "description": "Prolonged moderate-intensity aerobic exercise at 70–80% HRreserve"},

        {"id": "cholesterol_elevated_aerobic_rec", "name": "Elevated Cholesterol Aerobic Recommendation",
         "condition": "high_cholesterol", "patient_group": "elevated_cholesterol", "exercise_type": "aerobic",
         "intensity": {"type": "moderate-to-high", "initial_range": {"min": 70, "max": 80}, "progression": 85},
         "description": "Prolonged moderate-intensity aerobic exercise at 70–80% HRreserve, progressing to 85% HRmax"},

        {"id": "cholesterol_elevated_resistance_rec", "name": "Elevated Cholesterol Resistance Recommendation",
         "condition": "high_cholesterol", "patient_group": "elevated_cholesterol", "exercise_type": "resistance",
         "intensity": {"type": "moderate-to-high", "range": {"min": 75, "max": 85}, "unit": "1RM"},
         "description": "Moderate to high-intensity resistance training at 75–85% 1RM"}
    ]

    for rec in recommendations:
        node_id = rec["id"]
        G.add_node(
            node_id,
            type=NodeType.RECOMMENDATION.value,
            name=rec["name"],
            exercise_type=rec["exercise_type"],
            frequency=rec.get("frequency"),
            intensity=rec.get("intensity"),
            sets=rec.get("sets"),
            repetitions=rec.get("repetitions"),
            duration=rec.get("duration"),
            description=rec["description"]
        )

        # Add edges from condition to recommendation
        G.add_edge(
            rec["condition"],
            node_id,
            type=RelationType.RECOMMENDS.value
        )

        # Add edges from exercise type to recommendation
        G.add_edge(
            rec["exercise_type"],
            node_id,
            type=RelationType.INCLUDES.value
        )

        # Add patient group relations if applicable
        if "patient_group" in rec:
            G.add_edge(
                rec["patient_group"],
                node_id,
                type=RelationType.APPLIES_TO.value
            )

    # Add effectiveness relationships
    effectiveness_data = [
        # Blood pressure effectiveness
        {"health_param": "blood_pressure", "exercise_type": "resistance", "rating": "small"},
        {"health_param": "blood_pressure", "exercise_type": "aerobic", "rating": "moderate"},
        {"health_param": "blood_pressure", "exercise_type": "combined", "rating": "moderate"},

        # Lipid profile effectiveness
        {"health_param": "lipid_profile", "exercise_type": "resistance", "rating": "small"},
        {"health_param": "lipid_profile", "exercise_type": "aerobic", "rating": "moderate"},
        {"health_param": "lipid_profile", "exercise_type": "combined", "rating": "large"},

        # Glycemic control effectiveness
        {"health_param": "glycemic_control", "exercise_type": "resistance", "rating": "moderate"},
        {"health_param": "glycemic_control", "exercise_type": "aerobic", "rating": "moderate"},
        {"health_param": "glycemic_control", "exercise_type": "combined", "rating": "large"},

        # Bodyweight loss effectiveness
        {"health_param": "bodyweight_loss", "exercise_type": "resistance", "rating": "small"},
        {"health_param": "bodyweight_loss", "exercise_type": "aerobic", "rating": "moderate"},
        {"health_param": "bodyweight_loss", "exercise_type": "combined", "rating": "large"}
    ]

    for item in effectiveness_data:
        # Create an edge ID for the effectiveness relationship
        edge_id = f"{item['exercise_type']}_{item['health_param']}_effectiveness"

        # Add the relationship between exercise type and health parameter
        G.add_edge(
            item["exercise_type"],
            item["health_param"],
            type=RelationType.AFFECTS.value,
            rating=item["rating"],
            rating_id=item["rating"]  # Store the rating ID for lookup
        )

        # Add a relationship between the health parameter and the rating
        G.add_edge(
            item["health_param"],
            item["rating"],
            type=RelationType.HAS_EFFECTIVENESS.value,
            exercise_type=item["exercise_type"]  # Context for which exercise type
        )

    # Connect conditions to health parameters
    condition_parameter_mappings = [
        {"condition": "diabetes", "parameter": "glycemic_control"},
        {"condition": "hypertension", "parameter": "blood_pressure"},
        {"condition": "high_cholesterol", "parameter": "lipid_profile"},
        {"condition": "obesity", "parameter": "bodyweight_loss"}
    ]

    for mapping in condition_parameter_mappings:
        G.add_edge(
            mapping["condition"],
            mapping["parameter"],
            type=RelationType.AFFECTS.value
        )

    # Connect conditions to monitoring guidance
    condition_monitoring_mappings = [
        {"condition": "diabetes", "guidance": "diabetes_glucose_monitoring"},
        {"condition": "diabetes", "guidance": "diabetes_carb_preparation"},
        {"condition": "hypertension", "guidance": "hypertension_bp_monitoring"},
        {"condition": "hypertension", "guidance": "hypertension_exertion"},
        {"condition": "high_cholesterol", "guidance": "cholesterol_consistency"}
    ]

    for mapping in condition_monitoring_mappings:
        G.add_edge(
            mapping["condition"],
            mapping["guidance"],
            type=RelationType.REQUIRES_MONITORING.value
        )

    # Connect conditions to health notes
    condition_note_mappings = [
        {"condition": "diabetes", "note": "diabetes_timing"},
        {"condition": "hypertension", "note": "hypertension_morning"},
        {"condition": "hypertension", "note": "hypertension_breathing"},
        {"condition": "hypertension", "note": "hypertension_valsalva"},
        {"condition": "high_cholesterol", "note": "cholesterol_aerobic"}
    ]

    for mapping in condition_note_mappings:
        G.add_edge(
            mapping["condition"],
            mapping["note"],
            type=RelationType.HAS_NOTE.value
        )

        # Connect conditions to treatment pathways
        G.add_edge("hypertension", "bp_normal", type=RelationType.HAS_TREATMENT_PATHWAY.value)
        G.add_edge("hypertension", "bp_elevated", type=RelationType.HAS_TREATMENT_PATHWAY.value)
        G.add_edge("high_cholesterol", "cholesterol_low_risk", type=RelationType.HAS_TREATMENT_PATHWAY.value)

        # Connect conditions to patient groups
        G.add_edge("high_cholesterol", "cholesterol_healthy", type=RelationType.INCLUDES.value)
        G.add_edge("high_cholesterol", "elevated_cholesterol", type=RelationType.INCLUDES.value)
        G.add_edge("high_cholesterol", "elevated_cholesterol_limited_mobility", type=RelationType.INCLUDES.value)

        # Connect guidelines to conditions they cover
        G.add_edge("aha", "hypertension", type=RelationType.APPLIES_TO.value)
        G.add_edge("aha", "high_cholesterol", type=RelationType.APPLIES_TO.value)
        G.add_edge("diabetes_guidelines", "diabetes", type=RelationType.APPLIES_TO.value)
        G.add_edge("hypertension_guidelines", "hypertension", type=RelationType.APPLIES_TO.value)
        G.add_edge("cholesterol_guidelines", "high_cholesterol", type=RelationType.APPLIES_TO.value)

        # General Singapore PA guidelines apply to all conditions
        for condition in ["diabetes", "hypertension", "high_cholesterol", "obesity"]:
            G.add_edge("singapore_pa", condition, type=RelationType.APPLIES_TO.value)

        # Connect modality effectiveness guideline to all exercise types
        for ex_type in ["aerobic", "resistance", "combined"]:
            G.add_edge("modality_effectiveness", ex_type, type=RelationType.SOURCE_OF.value)

        return G

    def get_default_condition_nodes():
        """Return default condition nodes for easier access"""
        return {
            "diabetes": {
                "type": NodeType.HEALTH_CONDITION.value,
                "name": "Diabetes",
                "description": "Type 2 Diabetes"
            },
            "hypertension": {
                "type": NodeType.HEALTH_CONDITION.value,
                "name": "Hypertension",
                "description": "High Blood Pressure"
            },
            "high_cholesterol": {
                "type": NodeType.HEALTH_CONDITION.value,
                "name": "High Cholesterol",
                "description": "Elevated Cholesterol Levels"
            },
            "obesity": {
                "type": NodeType.HEALTH_CONDITION.value,
                "name": "Obesity",
                "description": "Excess Body Fat"
            }
        }

    def get_default_exercise_type_nodes():
        """Return default exercise type nodes for easier access"""
        return {
            "aerobic": {
                "type": NodeType.EXERCISE_TYPE.value,
                "name": "Aerobic",
                "description": "Cardiovascular exercise that increases heart rate"
            },
            "resistance": {
                "type": NodeType.EXERCISE_TYPE.value,
                "name": "Resistance",
                "description": "Strength training using weights or resistance"
            },
            "flexibility": {
                "type": NodeType.EXERCISE_TYPE.value,
                "name": "Flexibility",
                "description": "Stretching exercises to improve range of motion"
            },
            "combined": {
                "type": NodeType.EXERCISE_TYPE.value,
                "name": "Combined",
                "description": "Workout combining multiple types of exercise"
            }
        }

"""# [Updated] Feature: Plan Generator Class"""

class GraphTraversalExercisePlanGenerator:
    """
    Exercise plan generator that uses graph traversal to navigate clinical guidelines.
    """

    def __init__(self, exercises_data, user_profile, graph=None):
        self.exercises_data = exercises_data
        self.user_profile = user_profile
        self.graph = graph or create_guidelines_graph()

        # Extract profile information
        self.fitness_level = user_profile.get('fitness_info', {}).get('fitness_level', 'intermediate')
        self.fitness_goal = user_profile.get('fitness_info', {}).get('fitness_goal', 'general')
        self.days_per_week = user_profile.get('preferences', {}).get('sessions_per_week', 3)

        # Convert health profile to graph node IDs
        self.health_conditions = []
        if user_profile.get('health_conditions', {}).get('has_diabetes', False):
            self.health_conditions.append('diabetes')
        if user_profile.get('health_conditions', {}).get('has_hypertension', False):
            self.health_conditions.append('hypertension')
        if user_profile.get('health_conditions', {}).get('has_high_cholesterol', False):
            self.health_conditions.append('high_cholesterol')
        if user_profile.get('health_conditions', {}).get('has_obesity', False):
            self.health_conditions.append('obesity')

        # Store used exercises to ensure variety
        self.used_exercises = set()

    def traverse_graph(self, start_nodes, target_types=None, relation_types=None,
                      max_depth=3, return_paths=False):
        """Generic graph traversal function using BFS."""
        if isinstance(start_nodes, str):
            start_nodes = [start_nodes]

        found_nodes = []
        visited = set()
        queue = [(node, 0, [node]) for node in start_nodes]

        while queue:
            current_node, depth, path = queue.pop(0)

            if current_node in visited or depth > max_depth:
                continue

            visited.add(current_node)

            if current_node in self.graph:
                node_data = self.graph.nodes[current_node]

                # Check if this node matches our target types
                if target_types is None or node_data.get('type') in target_types:
                    if return_paths:
                        found_nodes.append((current_node, node_data, path))
                    else:
                        found_nodes.append((current_node, node_data))

                # Continue traversal
                for source, target, edge_data in self.graph.edges(current_node, data=True):
                    if relation_types is None or edge_data.get('type') in relation_types:
                        if target not in visited:
                            queue.append((target, depth + 1, path + [target]))

        return found_nodes

    def find_recommendations(self, condition_ids, exercise_type=None):
        """Find all recommendations for given conditions"""
        recommendations = self.traverse_graph(
            start_nodes=condition_ids,
            target_types=[NodeType.RECOMMENDATION.value],
            relation_types=[RelationType.RECOMMENDS.value, RelationType.HAS_GUIDELINE.value],
            max_depth=3
        )

        # Filter by exercise type if specified
        if exercise_type:
            recommendations = [
                (node_id, data) for node_id, data in recommendations
                if data.get('exercise_type') == exercise_type
            ]

        return recommendations

    def get_session_type_for_day(self, day_index):
        """Determine session type based on day and health conditions"""
        # For diabetes: prioritize resistance training
        if 'diabetes' in self.health_conditions:
            if self.days_per_week >= 3:
                # Day 0, 2: Resistance, Day 1: Cardio or Combined
                if day_index % 3 in [0, 2]:
                    return 'resistance'
                else:
                    return 'cardio' if 'hypertension' in self.health_conditions else 'combined'
            else:
                # Alternate between resistance and combined
                return 'resistance' if day_index % 2 == 0 else 'combined'

        # For hypertension/high cholesterol: prioritize cardio
        elif 'hypertension' in self.health_conditions or 'high_cholesterol' in self.health_conditions:
            if self.days_per_week >= 3:
                # Day 0, 2: Cardio, Day 1: Resistance
                if day_index % 3 in [0, 2]:
                    return 'cardio'
                else:
                    return 'resistance'
            else:
                # Alternate between cardio and combined
                return 'cardio' if day_index % 2 == 0 else 'combined'

        # Default: balanced approach
        else:
            if self.days_per_week >= 3:
                # Rotate through different types
                types = ['cardio', 'resistance', 'combined']
                return types[day_index % 3]
            else:
                return 'combined'

    def get_exercise_priorities(self):
        """Get exercise priorities for the user's conditions"""
        priorities = {}

        if 'diabetes' in self.health_conditions:
            priorities['resistance'] = {
                'importance': 'high',
                'focus_muscles': ['Legs', 'Back', 'Chest'],  # Large muscle groups
                'intensity': 'moderate-high',
                'benefit': 'Improves insulin sensitivity and glucose control'
            }
            priorities['cardio'] = {
                'importance': 'medium',
                'intensity': 'moderate',
                'benefit': 'Helps with glucose management'
            }

        if 'hypertension' in self.health_conditions:
            priorities['cardio'] = {
                'importance': 'high',
                'intensity': 'moderate',
                'benefit': 'Reduces blood pressure'
            }
            priorities['resistance'] = {
                'importance': 'medium',
                'intensity': 'low-moderate',
                'sets': '1',
                'reps': '12-15',
                'benefit': 'Supports cardiovascular health'
            }

        if 'high_cholesterol' in self.health_conditions:
            priorities['cardio'] = {
                'importance': 'high',
                'intensity': 'moderate-vigorous',
                'duration_modifier': 1.3,  # 30% longer cardio
                'benefit': 'Improves lipid profile'
            }

        return priorities

    def select_varied_exercises(self, muscle_groups, exercise_type, count=3):
        """Select exercises ensuring variety across sessions"""
        # Filter available exercises
        available_exercises = self.exercises_data[
            (self.exercises_data['Exercise_Type'] == exercise_type) &
            (~self.exercises_data['Exercise_Name'].isin(self.used_exercises))
        ]

        # If we've used too many exercises, allow reuse but prefer new ones
        if len(available_exercises) < count:
            available_exercises = self.exercises_data[
                self.exercises_data['Exercise_Type'] == exercise_type
            ]

        selected_exercises = []
        priorities = self.get_exercise_priorities()

        # For resistance exercises with diabetes, prioritize compound movements
        if exercise_type == 'Resistance' and 'diabetes' in self.health_conditions:
            # Prioritize compound exercises
            compound_keywords = ['squat', 'deadlift', 'press', 'row', 'pull', 'lunge']
            compound_exercises = available_exercises[
                available_exercises['Exercise_Name'].str.lower().str.contains('|'.join(compound_keywords))
            ]

            # Select compound exercises first
            if len(compound_exercises) > 0:
                for _, exercise in compound_exercises.head(min(2, count)).iterrows():
                    selected_exercises.append(exercise)
                    self.used_exercises.add(exercise['Exercise_Name'])

        # Fill remaining slots with exercises from target muscle groups
        remaining_count = count - len(selected_exercises)
        if remaining_count > 0:
            for i, muscle in enumerate(muscle_groups):
                if len(selected_exercises) >= count:
                    break

                muscle_exercises = available_exercises[
                    (available_exercises['Main_muscle'] == muscle) &
                    (~available_exercises['Exercise_Name'].isin([ex['Exercise_Name'] for ex in selected_exercises]))
                ]

                if len(muscle_exercises) > 0:
                    exercise = muscle_exercises.iloc[0]
                    selected_exercises.append(exercise)
                    self.used_exercises.add(exercise['Exercise_Name'])

        # If still need more exercises, just take what's available
        while len(selected_exercises) < count and len(available_exercises) > len(selected_exercises):
            remaining_exercises = available_exercises[
                ~available_exercises['Exercise_Name'].isin([ex['Exercise_Name'] for ex in selected_exercises])
            ]
            if len(remaining_exercises) > 0:
                exercise = remaining_exercises.iloc[0]
                selected_exercises.append(exercise)
                self.used_exercises.add(exercise['Exercise_Name'])
            else:
                break

        return selected_exercises

    def create_session(self, day_index, session_type):
        """Create a workout session for a specific day"""
        days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        day_name = days[day_index % 7]

        session = {
            'name': f"{session_type.title()} - {day_name}",
            'day': day_name,
            'session_type': session_type,
            'exercises': [],
            'estimated_duration': 45,  # Base duration
            'monitoring_notes': []
        }

        # Get priorities for exercise selection
        priorities = self.get_exercise_priorities()

        # Define exercise counts based on session type and fitness level
        if self.fitness_level == 'beginner':
            if session_type == 'resistance':
                exercise_counts = {'Resistance': 3, 'Cardio': 1, 'Flexibility': 2}
            elif session_type == 'cardio':
                exercise_counts = {'Cardio': 2, 'Resistance': 1, 'Flexibility': 2}
            else:  # combined
                exercise_counts = {'Resistance': 2, 'Cardio': 2, 'Flexibility': 2}
        else:
            if session_type == 'resistance':
                exercise_counts = {'Resistance': 4, 'Cardio': 1, 'Flexibility': 2}
            elif session_type == 'cardio':
                exercise_counts = {'Cardio': 3, 'Resistance': 1, 'Flexibility': 2}
            else:  # combined
                exercise_counts = {'Resistance': 2, 'Cardio': 2, 'Flexibility': 2}

        # Select muscle groups based on session type and conditions
        if session_type == 'resistance':
            if 'diabetes' in self.health_conditions:
                muscle_groups = ['Legs', 'Back', 'Chest', 'Shoulders']  # Large muscle groups
            else:
                muscle_groups = ['Chest', 'Back', 'Legs', 'Shoulders', 'Arms']
        else:
            muscle_groups = ['Legs', 'Core', 'Back', 'Chest']

        # Select exercises for each type
        for ex_type, count in exercise_counts.items():
            exercises = self.select_varied_exercises(muscle_groups, ex_type, count)

            for exercise in exercises:
                exercise_detail = {
                    'name': exercise['Exercise_Name'],
                    'type': ex_type,
                    'main_muscle': exercise['Main_muscle'],
                    'equipment': exercise.get('Equipment', 'Bodyweight')
                }

                # Add exercise-specific details based on type and conditions
                if ex_type == 'Resistance':
                    if 'diabetes' in self.health_conditions:
                        exercise_detail.update({
                            'sets': '2-3',
                            'reps': '8-12',
                            'rest': '60-90 seconds',
                            'intensity_note': 'Moderate to vigorous intensity',
                            'benefit': 'Improves insulin sensitivity'
                        })
                    elif 'hypertension' in self.health_conditions:
                        exercise_detail.update({
                            'sets': '1',
                            'reps': '12-15',
                            'rest': '60-90 seconds',
                            'intensity_note': 'Low to moderate intensity',
                            'benefit': 'Supports cardiovascular health'
                        })
                    else:
                        exercise_detail.update({
                            'sets': '3',
                            'reps': '10-12',
                            'rest': '60-90 seconds'
                        })

                elif ex_type == 'Cardio':
                    base_duration = 20 if self.fitness_level == 'beginner' else 30

                    if 'high_cholesterol' in self.health_conditions:
                        duration = int(base_duration * 1.3)  # 30% longer
                        exercise_detail.update({
                            'duration': f'{duration} minutes',
                            'intensity': 'Moderate to vigorous',
                            'benefit': 'Improves cholesterol levels'
                        })
                    elif 'hypertension' in self.health_conditions:
                        exercise_detail.update({
                            'duration': f'{base_duration} minutes',
                            'intensity': 'Moderate (40-70% VO2 reserve)',
                            'benefit': 'Helps lower blood pressure'
                        })
                    else:
                        exercise_detail.update({
                            'duration': f'{base_duration} minutes',
                            'intensity': 'Moderate'
                        })

                else:  # Flexibility
                    exercise_detail.update({
                        'duration': '30 seconds',
                        'sets': '2',
                        'note': 'Hold each stretch without bouncing'
                    })

                session['exercises'].append(exercise_detail)

        # Add monitoring notes based on conditions
        if 'diabetes' in self.health_conditions:
            session['monitoring_notes'].append('Check blood glucose before and after exercise')
            session['monitoring_notes'].append('Have fast-acting carbohydrates available')

        if 'hypertension' in self.health_conditions:
            session['monitoring_notes'].append('Monitor blood pressure if possible')
            session['monitoring_notes'].append('Use perceived exertion scale (11-14 on Borg scale)')

        # Calculate realistic duration
        total_duration = 10  # Warm-up and cool-down
        for exercise in session['exercises']:
            if exercise['type'] == 'Resistance':
                sets = exercise.get('sets', '3')
                if '-' in sets:
                    avg_sets = (int(sets.split('-')[0]) + int(sets.split('-')[1])) / 2
                else:
                    avg_sets = int(sets)
                total_duration += avg_sets * 1.5  # 1.5 minutes per set including rest

            elif exercise['type'] == 'Cardio':
                duration_str = exercise.get('duration', '20 minutes')
                duration = int(duration_str.split()[0])
                total_duration += duration

            else:  # Flexibility
                total_duration += 1  # 1 minute per flexibility exercise

        session['estimated_duration'] = int(round(total_duration / 5) * 5)  # Round to nearest 5

        return session

    def generate_plan(self):
        """Generate a complete workout plan"""
        # Reset used exercises for this plan
        self.used_exercises.clear()

        # Find health notes and monitoring guidance from graph
        health_notes = []
        monitoring_guidance = []

        for condition in self.health_conditions:
            # Find health notes
            notes = self.traverse_graph(
                start_nodes=[condition],
                target_types=[NodeType.HEALTH_NOTE.value],
                relation_types=[RelationType.HAS_NOTE.value],
                max_depth=1
            )
            for _, note_data in notes:
                health_notes.append(note_data.get('description', ''))

            # Find monitoring guidance
            guidance = self.traverse_graph(
                start_nodes=[condition],
                target_types=[NodeType.MONITORING_GUIDANCE.value],
                relation_types=[RelationType.REQUIRES_MONITORING.value],
                max_depth=1
            )
            for _, guide_data in guidance:
                monitoring_guidance.append(guide_data.get('description', ''))

        # Create workout sessions
        workout_sessions = []
        for day in range(self.days_per_week):
            session_type = self.get_session_type_for_day(day)
            session = self.create_session(day, session_type)
            workout_sessions.append(session)

        # Find effectiveness analysis
        effectiveness_analysis = self.find_effectiveness_paths(self.health_conditions)

        # Count resistance sessions
        resistance_sessions = sum(1 for session in workout_sessions if session['session_type'] == 'resistance')

        # Compile the plan
        plan = {
            'user_id': self.user_profile.get('user_id', 'anonymous'),
            'plan_type': 'health_based',
            'fitness_level': self.fitness_level,
            'fitness_goal': self.fitness_goal,
            'health_conditions': {condition: True for condition in self.health_conditions},
            'sessions_per_week': self.days_per_week,
            'resistance_sessions_per_week': resistance_sessions,
            'recommended_weekly_minutes': self.calculate_weekly_minutes(),
            'workout_sessions': workout_sessions,
            'health_notes': list(set(health_notes)),  # Remove duplicates
            'monitoring_guidance': list(set(monitoring_guidance)),
            'effectiveness_analysis': effectiveness_analysis
        }

        return plan

    def calculate_weekly_minutes(self):
        """Calculate recommended weekly minutes based on conditions"""
        base_minutes = 150

        if 'high_cholesterol' in self.health_conditions:
            base_minutes = int(base_minutes * 1.2)  # 20% more for cholesterol

        if 'obesity' in self.health_conditions:
            base_minutes = int(base_minutes * 1.3)  # 30% more for weight loss

        return base_minutes

    def find_effectiveness_paths(self, condition_ids):
        """Find effectiveness ratings for exercises on health parameters"""
        effectiveness_data = {}

        # For each condition, find affected health parameters
        for condition_id in condition_ids:
            params = self.traverse_graph(
                start_nodes=[condition_id],
                target_types=[NodeType.HEALTH_PARAMETER.value],
                relation_types=[RelationType.AFFECTS.value],
                max_depth=1
            )

            for param_id, param_data in params:
                exercise_effects = []

                # Find exercise effects on this parameter
                for source, target, edge_data in self.graph.in_edges(param_id, data=True):
                    if (edge_data.get('type') == RelationType.AFFECTS.value and
                        self.graph.nodes[source].get('type') == NodeType.EXERCISE_TYPE.value):

                        rating_id = edge_data.get('rating_id')
                        if rating_id and rating_id in self.graph.nodes:
                            rating_data = self.graph.nodes[rating_id]
                            exercise_effects.append({
                                'exercise_type': source,
                                'exercise_data': self.graph.nodes[source],
                                'rating': rating_data
                            })

                effectiveness_data[param_id] = {
                    'parameter': param_data,
                    'exercise_effects': exercise_effects
                }

        return effectiveness_data

    @staticmethod
    def print_plan_summary(plan):
        """Print a formatted summary of the exercise plan"""
        print("\n📋 Health-Based Exercise Plan Summary:")
        print(f"• Fitness level: {plan['fitness_level'].capitalize()}")
        print(f"• Fitness goal: {plan.get('fitness_goal', 'General').capitalize()}")

        # Print health conditions
        conditions = []
        for condition, has in plan['health_conditions'].items():
            if has:
                conditions.append(condition.replace('_', ' ').capitalize())

        if conditions:
            print(f"• Health conditions: {', '.join(conditions)}")

        print(f"• Total sessions: {plan['sessions_per_week']}")
        print(f"• Resistance sessions per week: {plan['resistance_sessions_per_week']}")
        print(f"• Recommended weekly minutes: {plan['recommended_weekly_minutes']}")

        # Print health notes
        if plan.get('health_notes'):
            print("\n🩺 Health Notes:")
            for note in plan['health_notes']:
                print(f"  - {note}")

        # Print monitoring guidance
        if plan.get('monitoring_guidance'):
            print("\n📊 Monitoring Guidance:")
            for guidance in plan['monitoring_guidance']:
                print(f"  - {guidance}")

        # Print workout schedule
        print("\n📅 Workout Schedule:")
        for i, session in enumerate(plan['workout_sessions']):
            print(f"\n🏋️ Workout {i+1}: {session['name']} ({session['estimated_duration']} min)")

            # Print monitoring notes for this session
            if session.get('monitoring_notes'):
                print("  Monitoring notes:")
                for note in session['monitoring_notes']:
                    print(f"  • {note}")

            print("\n  Exercises:")
            for j, exercise in enumerate(session['exercises']):
                print(f"  {j+1}. {exercise['name']} ({exercise['type']})")

                # Print exercise details based on type
                if exercise['type'] == 'Resistance':
                    print(f"     Sets: {exercise.get('sets', '3')}")
                    print(f"     Reps: {exercise.get('reps', '10-12')}")
                    print(f"     Rest: {exercise.get('rest', '60-90 seconds')}")
                    if 'intensity_note' in exercise:
                        print(f"     Intensity: {exercise['intensity_note']}")
                    if 'benefit' in exercise:
                        print(f"     Benefit: {exercise['benefit']}")

                elif exercise['type'] == 'Cardio':
                    print(f"     Duration: {exercise.get('duration', '20 minutes')}")
                    if 'intensity' in exercise:
                        print(f"     Intensity: {exercise['intensity']}")
                    if 'benefit' in exercise:
                        print(f"     Benefit: {exercise['benefit']}")

                else:  # Flexibility
                    print(f"     Duration: {exercise.get('duration', '30 seconds')}")
                    print(f"     Sets: {exercise.get('sets', '2')}")
                    if 'note' in exercise:
                        print(f"     Note: {exercise['note']}")

                if exercise.get('equipment') and exercise['equipment'] != 'Bodyweight':
                    print(f"     Equipment: {exercise['equipment']}")


    def get_graph_based_plan_summary(plan):
        """Generate a formatted summary of the exercise plan as a string."""
        summary = "\n📋 Health-Based Exercise Plan Summary:\n"
        summary += f"• Fitness level: {plan['fitness_level'].capitalize()}\n"
        summary += f"• Fitness goal: {plan.get('fitness_goal', 'General').capitalize()}\n"

        # Add health conditions
        conditions = []
        for condition, has in plan['health_conditions'].items():
            if has:
                conditions.append(condition.replace('_', ' ').capitalize())

        if conditions:
            summary += f"• Health conditions: {', '.join(conditions)}\n"

        summary += f"• Total sessions: {plan['sessions_per_week']}\n"
        summary += f"• Resistance sessions per week: {plan['resistance_sessions_per_week']}\n"
        summary += f"• Recommended weekly minutes: {plan['recommended_weekly_minutes']}\n"

        # Add health notes
        if plan.get('health_notes'):
            summary += "\n🩺 Health Notes:\n"
            for note in plan['health_notes']:
                summary += f"  - {note}\n"

        # Add monitoring guidance
        if plan.get('monitoring_guidance'):
            summary += "\n📊 Monitoring Guidance:\n"
            for guidance in plan['monitoring_guidance']:
                summary += f"  - {guidance}\n"

        # Add workout schedule
        summary += "\n📅 Workout Schedule:\n"
        for i, session in enumerate(plan['workout_sessions']):
            summary += f"\n🏋️ Workout {i+1}: {session['name']} ({session['estimated_duration']} min)\n"

            # Add monitoring notes for this session
            if session.get('monitoring_notes'):
                summary += "  Monitoring notes:\n"
                for note in session['monitoring_notes']:
                    summary += f"  • {note}\n"

            summary += "\n  Exercises:\n"
            for j, exercise in enumerate(session['exercises']):
                summary += f"  {j+1}. {exercise['name']} ({exercise['type']})\n"

                # Add exercise details based on type
                if exercise['type'] == 'Resistance':
                    summary += f"     Sets: {exercise.get('sets', '3')}\n"
                    summary += f"     Reps: {exercise.get('reps', '10-12')}\n"
                    summary += f"     Rest: {exercise.get('rest', '60-90 seconds')}\n"
                    if 'intensity_note' in exercise:
                        summary += f"     Intensity: {exercise['intensity_note']}\n"
                    if 'benefit' in exercise:
                        summary += f"     Benefit: {exercise['benefit']}\n"

                elif exercise['type'] == 'Cardio':
                    summary += f"     Duration: {exercise.get('duration', '20 minutes')}\n"
                    if 'intensity' in exercise:
                        summary += f"     Intensity: {exercise['intensity']}\n"
                    if 'benefit' in exercise:
                        summary += f"     Benefit: {exercise['benefit']}\n"

                else:  # Flexibility
                    summary += f"     Duration: {exercise.get('duration', '30 seconds')}\n"
                    summary += f"     Sets: {exercise.get('sets', '2')}\n"
                    if 'note' in exercise:
                        summary += f"     Note: {exercise['note']}\n"

                if exercise.get('equipment') and exercise['equipment'] != 'Bodyweight':
                    summary += f"     Equipment: {exercise['equipment']}\n"

        return summary

def print_exercise_plan_summary(plan: dict):
    """
    Print a formatted summary of the exercise plan.

    Parameters:
    -----------
    plan : dict
        The exercise plan to summarize.
    """
    GraphTraversalExercisePlanGenerator.print_plan_summary(plan)

def get_exercise_plan_summary(user_profile: dict):
    """
    Print a formatted summary of the exercise plan.

    Parameters:
    -----------
    plan : dict
        The exercise plan to summarize.
    """
    # Print the summary
    # plan_summary = GuidelineBasedExercisePlanGenerator.get_plan_summary(plan)
    # user_profile = SAMPLE_USER_PROFILE

    # Create the graph
    graph = create_guidelines_graph()

    # Create generator directly with the graph
    generator = GraphTraversalExercisePlanGenerator(
        exercises_data=combined_exercises_df,
        user_profile=user_profile,
        graph=graph
    )

    # Generate the plan
    plan = generator.generate_plan()

    # Print the summary
    # GraphTraversalExercisePlanGenerator.print_plan_summary(plan)
    plan_summary = GraphTraversalExercisePlanGenerator.get_graph_based_plan_summary(plan)
    return plan_summary
user_profile = SAMPLE_USER_PROFILE

# Create the graph
graph = create_guidelines_graph()

# Create generator directly with the graph
generator = GraphTraversalExercisePlanGenerator(
    exercises_data=combined_exercises_df,
    user_profile=user_profile,
    graph=graph
)

# Generate the plan
plan = generator.generate_plan()

# Print the summary
GraphTraversalExercisePlanGenerator.print_plan_summary(plan)

